"use strict";

var util = require('util');
var fs = require('fs');
var _ = require('lodash');
var Busboy = require('busboy');

// A collection of optional parsers. See below.
//
var ajv = require('ajv')();
var jsen = require('jsen');
var isMyJsonValid = require('is-my-json-valid');

var validators = {
    ajv : function $ajv(schema) {
        return ajv.compile(schema);
    },
    jsen : function $jsen(schema) {
        return jsen(schema);
    },
    isMyJsonValid : function $isMyJsonValid(schema) {
        // #verbose ensures .errors property on error
        //
        return isMyJsonValid(schema, {
            verbose: true
        });
    }
};

var defaultValidator = 'ajv';

module.exports = function(opts) {

    // Configure general options on initialization
    // TODO: options for setting maximums (payload size, fields, etc)
    //
    if(!_.isPlainObject(opts || {})) {
        throw new Error('jsonschema-api constructor received non-Object as argument');
    }

    // TODO: merge any sent #opts
    //
    var trackedRESTMethods = [
        'POST',
        'PUT'
    ];

    var validator = validators[opts.validator] || validators[defaultValidator];

    // TODO: add busboy limits
    //
    var limits = opts.limits || {};

    function useBusboy(req, done) {

        var json = {};

        var busboy = new Busboy({
            headers: req.headers
        });
        busboy.on('file', function(fieldname, file, filename, encoding, mimetype) {

            // Only interested in JSON files. Note that a non-json file can
            // still be sent by spoofing types. That situation is corrected
            // below when the stream end is handled.
            //
            if(mimetype !== 'application/json') {
                return file.resume();
            }

            var jbody = '';

            //var fout = fs.createWriteStream('./tempout.json');
           // file.pipe(fout);
            console.log('File [' + fieldname + ']: filename: ' + filename + ', encoding: ' + encoding + ', mimetype: ' + mimetype);
            file.on('data', function(data) {
                jbody += data.toString();
                console.log('File [' + fieldname + '] got ' + data.length + ' bytes');

            });
            file.on('end', function() {
                console.log('File [' + fieldname + '] Finished');

                try {
                    jbody = JSON.parse(jbody);
                    done(null, jbody);

                } catch(e) {
                    done(e);
                }
            });
        });
        busboy.on('field', function(fieldname, val, fieldnameTruncated, valTruncated) {
            console.log('Field [' + fieldname + ']: value: ' + util.inspect(val));
            json[fieldname] = val;
        });
        busboy.on('finish', function() {
            console.log('Done parsing form, got', json);
            done(null);
        });
        busboy.on('error', function(err){
            done(err);
        })
        req.pipe(busboy);
    }

    function schemaApiMain(req, res, done) {

        var _this = this;
        var jbody = '';
        var ctype;

        if(~trackedRESTMethods.indexOf(req.method)) {

            try {

                useBusboy(req, function (err, parsedJSON) {
                    if(err) {
                        throw new Error(err);
                    }
                    _this.validateAndContinue(parsedJSON, req, done);
                });

            } catch (e) {

                ctype = req.headers['content-type'];

                if (ctype !== 'application/json') {
                    return res.status(400).json({
                        message: "Content type not supported",
                        contentType: ctype
                    })
                }

                req.on('data', function (chunk) {
                    jbody += chunk;
                });

                req.on('end', function () {
                    try {
                        jbody = JSON.parse(jbody);
                        _this.validateAndContinue(jbody, req, done);
                    } catch (err) {
                        return done(err);
                    }
                })
            }

        // TODO: configure to build OPTIONS response of
        // schema, and a preflight payload test route?
        //
        } else if(req.method === 'OPTIONS') {
            res.writeHead(200);
            res.end('OPTIONS HERE');
        } else {
            done();
        }
    }

    return function schemaApiCaller(schema) {
        return schemaApiMain.bind({
            compiledSchema : validator(schema),
            validateAndContinue : function validateAndContinue(json, req, done) {
                var validation = this.compiledSchema(json);
                req.validatedPayload = validation ? json : null;
                req.validationError = !validation
                    ? JSON.stringify(this.compiledSchema.errors)
                    : null;
                done(validation
                    ? null
                    : JSON.stringify(this.compiledSchema.errors));
            }
        });
    }
};